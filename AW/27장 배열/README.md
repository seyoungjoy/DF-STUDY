# 27장 배열

---

## 27.1 배열이란?
- 여러 개의 값을 순차적으로 나열한 자료구조
> ```js
> const arr = ['apple','banana','orange']
> ```
- 일반 객체와 다르게 값의 순서와 length 프로퍼티를 가짐
## 27.2 자바스크립트 배열은 배열이 아니다
- 일반적인 배열의 동작을 흉내 낸 특수한 객체
- JS 배열의 요소는 **프로퍼티 값**임
> - **일반 배열**: 인덱스로 요소에 빠르게 접근 가능 그러나 삽입 삭제가 비효율적 (인덱스는 제거가 아닌 사용하지 않음으로 남겨두기 때문)
> - **JS 배열**: 해시테이블 구조로 인해 느리게 접근 그러나 삽입 삭제가 효율적 (해시 테이블 데이터들은 정렬되어 있지 않다)

## 27.3 length 프로퍼티와 희소 배열
- JS는 sparse 배열을 문법적으로 허용 (희소 배열의 length는 희소 배열의 실제 요소 개수보다 언제나 크다)
- **하지만 쓰지 마셈**

## 27.4 배열 생성
- 배열 리터럴 생성이 가장 일반적이고 간편한 배열 생성 방식
- `new Array();`
- `Array.of(1,2,3)`
- `Array.from('Hello')`

## 27.5 배열 요소의 참조
  - 대괄호 표기법 사용
- `console.log(arr[0])`

## 27.6 배열 요소의 추가와 갱신
- 존재하지 않는 인덱스를 사용해 값을 할당하면 새로운 요소가 추가됨 (length 자동 갱신)
- 현재 배열의 length 프로퍼티 값보다 큰 인덱스로 추가하면 sparse 배열이 됨
- 정수 이외의 값을 인덱스처럼 사용하면 프로퍼티로 됨
- `arr[0] = 1;`

## 27.7 배열 요소의 삭제
- delete 는 sparse 배열이 되기때문에 쓰지말고
- `Array.prototype.splice` 메서드 사용
- => `arr.slice(1,1)`

## 27.8 배열 메서드
- mutator method : 원본 배열을 직접 변경
- accessor method : 새로운 배열을 생성하여 반환
> #### 1. Array.isArray
> - Array 생성자 함수의 정적 메서드
> - 전달된 인수가 배열이면 T 아니면 F 반환
> #### 2. Array.prototype.indexOf
> - Array 생성자 함수의 정적 메서드
> - 전달된 인수가 배열이면 T 아니면 F 반환
> - 배열에 **특정 요소가 존재하는지 확인**용
> - Array.prototype.includes 를 쓰면 가독성 더 조음
> #### 3. Array.prototype.push
> - 인수로 전달받은 모든 값을 원본 배열의 마지막 요소로 추가하고 변경된 length 프로퍼티 값을 반환
> - 원본배열 직접 변경
> - 추가할 요소가 하나뿐이면 `arr[arr.length] = 3;` 과 같은 length 메서드 쓰는게 남 
> #### 4. Array.prototype.pop
> - 마지막 요소를 제거하고 제거한 요소를 반환
> - 빈 배열일 시 undefined 반환
> - 원본배열 직접 변경
> - 스택형 자료구조 구현 
> #### 5. Array.prototype.unshift
> - 전달받은 값을 원본 배열의 선두에 요소로 추가하고 변경된 length 프로퍼티 값을 반환
> - 원본배열 직접 변경
> #### 6. Array.prototype.shift
> - 전달받은 값을 원본 배열의 선두에 요소로 제거하고 제거된 요소을 반환
> - 원본배열 직접 변경
> - 큐형 자료구조 구현
> #### 7. Array.prototype.concat
> - 전달받은 값을 원본배열의 마지막 요소로 추가하고 새로운 배열을 반환
> - 원본배열 변경하지 않음
> - push + unshift 메서드 대체 가능
> #### 8. Array.prototype.splice
> - 원본 배열의 중간에 요소를 추가하거나 중간에 있는 요소를 제거
> - 원본 배열 직접 변경
> - `arr.splice( 시작인덱스 , 제거할 인덱스 갯수 , 다시 넣을 요소들)`
> - 배열에서 특정 요소를 제거하려면 `indexOf`를 통해 인덱스를 취득한 다음 splice 사용
> #### 9. Array.prototype.slice
> - 전달된 범위들의 요소들을 복사하여 배열로 반환
> - 원본 배열 변경 하지 않음
> - `arr.slice( 시작인덱스 , 종료인덱스)`
> #### 10. Array.prototype.join
> - 원본 배열의 모든 요소를 문자열로 변환한 후,인수로 전달 받은 문자열을 구분자로 연결한 문자열을 반환
> - `,` 를 `:` 등으로 바꿈
> #### 11. Array.prototype.reverse
> - 원본 배열의 순서를 반대로 뒤집는다
> - 원본 배열 직접 변경
> #### 11. Array.prototype.fill
> - 전달받은 값을 배열의 처음부터 끝까지 요소로 채운다
> - 원본 배열 직접 변경
> #### 12. Array.prototype.includes
> - 전달받은 값을 배열에서 검색하여 true 또는 false를 반환
> #### 12. Array.prototype.flat
> - 인수로 전달한 깊이 만큼 재귀적으로 배열을 평탄화
> - 체인을 인수의 스탭 만큼 위로 올려줌
## 27.9 배열 고차 함수
- 고차함수 : 함수를 인수로 전달받거나 함수를 반환하는 함수
> #### 1. Array.prototype.sort
> - 배열의 요소를 정렬한다 (오름차순 기본)
> - 원본 배열 직접 변경
> - sort 후 reverse 하면 내림차순
> - 숫자요소를 정렬할때에는 정렬 순서를 비교하는 비교 함수를 인수로 전달해야함: 유니코드 이슈 (`(a, b)=> a - b`)
> #### 2. Array.prototype.forEach
> - 배열의 요소를 순회하면서 수행해야할 처리를 콜백 함수로 전달받아 반복 호출
> - 원본 배열 변경 안함 (콜백함수로 변경은 가능)
> - 중간에 순회 중단 불가능 (for문과의 차이점)
> #### 3. Array.prototype.map
> - 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백함수를 반복호출 하며 새로운 배열 반환
> - 원본 배열 변경 안함
> - map이 생성하는 새로운 배열의 length는 호출한 배열의 length와 반드시 일치
> #### 4. Array.prototype.filter
> - 콜백함수의 변환값이 true인 요소로문 구성된 새로운 배열을 반환
> - filter가 생성하는 새로운 배열의 length는 호출한 배열의 length와 일치하거나 작다
> #### 4. Array.prototype.reduce
> - 모든 요소를 순회하며 인수로 전달받은 콜백 함수를 반복호출 및 콜백 함수의 반환값을 다음 순회시에 콜백 함수의 첫번째 인수로 전달하면서 하나의 결과값을 만들어 반환
> - 연속된 함수에서 살아남는 단 하나의 반환값 찾기
> - map, filter, some, every, find같은 고차함수는 reduce로 구현 가능 그러나 reduce는 항상 초기값을 전달해야함
> #### 5. Array.prototype.some
> - 모든 요소를 순회하면서 콜백 함수의 반환값이 단 한번이라도 참이면 true (빈 배열이면 언제나 false)
> #### 5. Array.prototype.every
> - 모든 요소를 순회하면서 콜백 함수의 반환값이 모두 참이면 true (빈 배열이면 언제나 true)
> #### 5. Array.prototype.find
> - 모든 요소를 순회하면서 첫번째로 true인 요소를 반환(없으면 undefined 반환)
> #### 5. Array.prototype.findIndex
> - 모든 요소를 순회하면서 첫번째로 true인 인덱스를 반환(없으면 -1 반환)
> #### 5. Array.prototype.flatMap
> - map 메서드와 flat 메서드를 순차적으로 실행하는 효과 (단, 1단계만 평탄화 가능)
> - 단계를 늘리고 싶을때는 map과 flat 각각 호출
---
# 끝