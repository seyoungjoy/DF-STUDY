# 24. 클로저

## 24.1 렉시컬 스코프
JS 엔진은 함수를 **어디서 정의했는지**에 따라 상위 스코프를 결정한다! 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 위치에 의해 결정된다.
<br><br>

## 24.2 함수 객체의 내부 슬롯
함수는 자신의 내부슬롯[[Environment]]에 자신이 정의된 환경, 상위 스코프의 참조를 저장한다.
함수 객체의 내부 슬롯 [[Environment]] 에 저장된 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 바로 상위 스코프다.
<br><br>

## 24.3 클로저와 렉시컬 환경
```js
const x = 1;
// 1
function outer() {
   const x = 10;
   const inner = function () { console.log(x); };  // 2
   return inner;
}
const innerFunc = outer(); // 3  
innerFunc(); //4 , 10 (외부값 참조)
```
outer 함수를 호출하면 inner함수를 반환하고 생명주기를 마감한다. -> outer 함수는 실행 컨텍스트 스택에서 제거되고 지역 변수도 자연스레 생명주기를 마감한다. -> 하지만 4번 innerFunc()의 값은 10이 나온다. 
이처럼 **외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다.**
이러한 중첩 함수를 클로저라고 부른다.
- 클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 중첩 함수가 외부 함수보다 더 오래 유지 되는 경우를 말한다!
<br><br>

## 24.4 클로저의 활용
상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.
<br>

```js
const increase = (function () { // 즉시 실행 함수
   let num = 0;
   return function () {
       return ++num; 
   };
}());

console.log(increase());
```
위의 예제는 즉시 실행 함수가 호출되고 increase 함수가 변수에 할당된다. increase 변수에 할당된 함수는 자신이 정의된 위치에 의해 결정된 상위 스코프인 즉시 실행 함수의 렉시컬 환경을 기억하는 클로저이다.
<br><br>

## 24.5 캡슐화와 정보 은닉
- 캡슐화: 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것
- 정보은닉: 객체의 특정 프로퍼티나 메서드를 감추는 것
<br><br>

## 24.6 자주 발생하는 실수
for문에 var 키워드로 선언한 변수는 함수 레벨 스코프를 갖기 때문에 전역 변수다. 이러한 이유가 오류를 발생시킬 수 있는데 이것을 해결해 주는것이
let 키워드를 사용하는것!    
let을 쓰면 for문의 코드 블록이 반복 될 때마다 독립적인 렉시컬 환경을 생성하여 식별자 값을 유지한다.