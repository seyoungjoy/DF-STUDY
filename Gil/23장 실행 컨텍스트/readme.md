<img src="https://capsule-render.vercel.app/api?type=waving&color=gradient&customColorList=1&height=200&section=header&text=Chapter23.%20%EC%8B%A4%ED%96%89%20%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8&fontSize=50">

# **23.1 소스코드의 타입**
소스코드는 크게 4가지 이며, 각 타입에 따라 실행컨텍스트를 생성하는 과정,관리 내용이 다르다. <br>
* **전역코드:** 전역에 존재하는 소스코드(전역에 정의된 함수,클래스의 내부코드는 포함X)
* **함수코드:** 함수 내부에 존재하는 소스코드(중첩함수, 중첩 클래스 등의 내부코드는 포함X)
* **eval코드:** 빌트인 전역 함수 eval 함수에 인수로 전달되어 실행되는 소스코드
* **모듈코드:** 모듈 내부에 존재하는 소스코드(모듈 안에 함수, 클래스등의 내부 코드는 포함X) test

<br>

```전역코드``` <br>
 1. 전역 스코프 생성
 2. var 키워드 변수, 함수 선언문으로 정의된 전역 함수를 전역객체 프로퍼티와 메서드로 바인딩
 3. 전역 코드 평가 후 전역 실행 컨텍스트 생성

<br>

 ```함수코드``` <br> 
 1. 지역 스코프 생성 후 지역 변수, 매개변수, arguments 관리
 2. 전역스코프와 스코프체인으로 연결
 3. 함수 코드 평가 후 함수 실행 컨텍스트 생성

 <br>

 ```eval코드``` <br>
 1. strict mode(엄격모드)에서 독자적 스코프 생성
 2. eval코드 평가 후 실행 컨텍스트 생성

 <br>

 ```모듈코드``` <br>
 1. 모듈별 독립 모듈스코프 생성
 2. 모듈코드 평가 후 모듈 실행 컨텍스트 생성

<br>

# **23.2 소스코드의 평가와 실행**
자바스크립트 엔진은 코드 실행을 위해서 **"소스코드 평가"** 와 **"소스코드 실행(런타임)"** 과정을 나눠서 처리한다.
<br>

```js
const x = 1;
const y = 1;

function Gil(a){
    const x = 10;
    const y = 15;
    
    console.log(a + x + y); //45
}

Gil(20);
console.log(x + y); // 2
```

### **```소스코드 평가```** <br>

1. 실행 컨텍스트 생성
2. 변수, 함수 등의 선언문 실행
3. 생성된 변수, 함수 식별자를 키로 스코프에 등록 <br>

### **```소스코드 실행(런타임)```** <br>

1. 변수, 함수의 참조 스코프에서 검색 후 취득
2. 결과값 실행컨텍스트에 재등록

<br>

# **23.3 실행 컨텍스트의 역할**

<br>

## **23.3.1 전역 코드 *평가***
* 변수선언문, 함수선언문 먼저 실행
* 결과로 생성된 전역변수, 전역함수 실행컨텍스트 내 전역 스코프에 등록

<br>

## **23.3.2 전역 코드 *실행***
* 전역변수 값 할당, 함수호출
* 함수 호출 시 코드 실행 순서를 변경 하여 함수 내부로 진입

<br>

## **23.3.3 함수 코드 *평가***
* (함수 내부) 매개변수, 지역변수 선언문 실행
* 생성된 매개변수, 지역변수 실행컨텍스트 내 지역스코프에 등록
* arguments 객체 생성 후 지역 스코프에 등록 및 this 바인딩 결정

<br>

## **23.3.4 함수 코드 *실행***
* console을 스코프체인에서 검색(console은 전역객체의 프로퍼티이다.)
* log를 프로퍼티타입 체인에서 검색
* console.log 표현식 평가(a+x+y) 이때 함수내부의 실행이 종료된다.
* 함수호출 이전으로 돌아가 전역 코드 실행을 재개

<br>

>### **스코프, 식별자 코드 실행 순서 등의 관리**
>1. 선언에 의해 생성된 모든 식별자(변수,함수,클래스 등)를 스코프를 구분, 등록하며 상태변화(식별자에 바인딩된 값의 변화)를 관리 할 수 있어야한다.
>2. 스코프 체인을 통해 상위 스코프로 이동하며 식별자를 검색 할 수 있어야한다.
>3. 현재 실행 중인 코드의 실행 순서를 변경 할 수 있고, 되돌아갈 수도 있어야한다.

<br>

# **23.4 실행 컨텍스트 스택**

```js
const x = 1;

function gil(){
    const y = 2;
    
    function young(){
        const z = 3;
        console.log(x + y + z);
    }
    young()
}
gil(); //6
```

위 예제에서 전역 코드를 평가하여 전역 실행 컨텍스트 생성하고 함수가 호출되면 함수코드를 평가하여 함수 실행 컨텍스트를 생성한다.<br>
이때 실행 컨텍스트는 스택(쌓임)자료구조로 관리가 되는데 이를 ```실행컨텍스트 스택```이라고 한다.

### **1. 전역 코드의 평가와 실행 (global)**
변수 x, 전역함수 gil이 전역 실행컨텍스트에 등록된다. 전역코드가 실행 되어 x에 1이 할당되고, gil이 호출된다.

<br>

### **2. gil 함수 코드의 평가와 실행 (gil)**
gil 호출 시 전역코드 실행 중지 후 gil 함수 내부의 함수 코드를 평가 해서 gil 함수 실행컨텍스트를 생성하고 실행컨텍스트 스택에 쌓인다. 그리고 지역변수 y와 중첩함수 young의 실행컨텍스트가 등록된다.
이후 gil함수가 실행 되어 지역변수 y에 값이 할당되고 중첩함수 young이 호출된다.

<br>

### **3. young 함수 코드의 평가와 실행 (young)**
young 호출 시 gil 실행 중지 후 young 함수 내부의 코드를 평가 하여 함수 실행 컨텍스트를 생성 하고 실행컨텍스트 스택에 쌓인다. 변수 z가 함수 실행컨텍스트에 등록 되고, young 함수가 실행 되어 z에 3이 할당 되며 console.log를 호출 후 종료된다.  

<br>

### **4. gil 함수 코드로 복귀 (gil)**
young 함수 실행 컨텍스트 스택을 삭제하며 종료된다.

<br>

### **5. 전역 코드로 복귀 (global)**
gil 함수 실행 컨텍스트 스택을 삭제하며 종료된다.

>위의 과정을 보면 실행 컨텍스트는 상위로 쌓인다. 그래서 현재 실행 중인 컨텍스트가 최상위에 존재한다. 

<br>

# **23.5 렉시컬 환경** <br>
렉시컬 환경은 식별자와 식별자에 바인딩된 값, 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트이다.

<br>

```환경 레코드``` <br>
스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리 하는 저장소

 <br>

```외부 렉시컬 환경에 대한 참조``` <br>
실행 컨텍스트를 생성한 소소코드를 포함하는 상위 코드의 렉시컬 환경을 말한다. 이를 통해 스코프 체인을 구현한다.

<br>

# **23.6 실행 컨텍스트의 생성과 식별자 검색 과정**

```js
var x = 1;
const y = 2;

function gil(a){
    var x = 3;
    const y = 4;
    
    function young(b){
        const z = 5;
        console.log(a + b + x + y + z);
    }
    young(10);
}
gil(20); //42
```

<br>

## ```전역 객체 생성``` <br>
전역 객체는 전역 코드가 평가되기 이전에 생성됩니다.
> 동작 환경에 따라 클라이언트 Web API 또는 특정 환경을 위한 호스트 객체를 포함합니다. <br> (DOM, BOM, XMLHTTPRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web Worker 등)

<br>

## ```전역 코드 평가``` <br>

1. 전역 실행 컨텍스트 생성
2. 전역 렉시컬 환경 생성
   1. 전역 환경 레코드 생성
      1. 객체 환경 레코드 생성
      2. 선언적 환경 레코드 생성
   2. this 바인딩
   3. 외부 렉시컬 환경에 대한 참조 결정

<br>

### 📌 전역 실행 컨텍스트 생성(A) <br>
전역 실행 컨텍스트를 생성하고 스택에 쌓임(실행 중인 실행 컨텍스트)

<br>

### 📌 전역 렉시컬 환경 생성(B) <br>
전역 렉시컬 환경을 생성하고 전역 실행 컨텍스트(A)에 바인딩

<br>

### 📌 객체 환경 레코드 생성(B-1) <br>
var 키워드로 선언한 전역 변수와 전역 함수 혹은 빌트인 전역 프로퍼티, 빌트인 전역 함수, 표준 빌트인 객체를 관리

<br>

### 📌 선언적 환경 레코드 생성(B-2) <br>
let, const 키워드로 선언한 전역 변수를 구분하여 관리 (이때 초기화 단계가 실행되지 않아 일시적 사각지대에 빠집니다.)

<br>

### 📌 this 바인딩(C) <br>
전역 환경 레코드에서 this는 전역 객체(window)를 가리키는데 gil은 전역 일반 함수이므로 window를 가리킴.

<br>

### 📌 외부 렉시컬 환경에 대한 참조 결정(D) <br>
전역 렉시컬 환경의 상위 스코프는 존재 하지 않으므로 null이 할당

<br>

## ```전역 코드 실행``` <br>

변수에 값이 할당, gil 함수 호출이 되는데 이때 어느 식별자를 참조 하는지 **식별자 결정**을 위해 검색을 한다. 
<br>해당 렉시컬 환경에서 찾을 수 없으면 상위로 이동한다. (현재 gil는 전역 실행 컨텍스트이므로 참조 에러가 뜬다.)

## ```gil 함수 코드 평가``` <br>
gil 함수가 호출되면 전역 코드 실행을 잠시 중단 후 함수 내부로 들어가 함수 코드 평가가 실행된다.

1. 함수 실행 컨텍스트 생성
2. 함수 렉시컬 환경 생성
    1. 함수 환경 레코드 생성
    2. this 바인딩
    3. 외부 렉시컬 환경에 대한 참조 결정

<br>

### 📌 함수 실행 컨텍스트 생성(A) <br>
gil 함수의 실행 컨텍스트를 생성 하고 스택에 쌓임.

<br>

### 📌 함수 렉시컬 환경 생성(B) <br>
gil 함수의 실행 컨텍스트를 생성 하고 스택에 쌓임.

<br>

### 📌 함수 환경 레코드 생성(B-1) <br>
gil 함수의 렉시컬 환경을 생성, 실행 컨텍스트(B)에 바인딩
(a 매개변수, arguments 객체, 함수 몸체에 선언된 식별자를 등록하고 관리)
<br>

### 📌 this 바인딩(B-2) <br>
호출 방식에 따라 this가 결정되지만 현재는 gil 함수가 일반선언 함수이므로 전역객체(window)에 바인딩

<br>

### 📌 외부 렉시컬 환경에 대한 참조 결정(B-3) <br>
상위 스코프인 전역 실행 컨텍스트를 참조하게 된다.

<br>

## ```gil 함수 코드 실행``` <br>
평가가 끝난 뒤 gil 함수를 실행 시키고, 실행 후에 gil 내부에서 선언된 변수들에 값이 할당, young 함수가 호출(식별자 검색) 된다.

<br>

## ```young 함수 코드 평가``` <br>
gil 함수와 동일한 과정을 거친다. 함수 실행컨텍스트를 생성하고 함수 렉시컬 환경 생성 후 this 바인딩, 참조 결정을 한다.

<br>

## ```young 함수 코드 실행``` <br>
console.log()가 실행 되어 console 식별자를 스코프체인에서 검색 후 찾아냈으면 표현식을 평가한다.(찾아 내지 못하면 참조 에러가 뜬다.)
<br>a,b,x,y,z 식별자(변수)도 동일하게 스코프체인을 통해서 검색 후에 결과를 호출한다.

<br>

## ```young 함수 코드 실행 종료``` <br>
console.log 메서드 호출 후 더 이상 실행할 코드가 없어 함수를 종료하고, 실행 컨텍스트에서 young 함수가 진행중 실행컨텍스트가 된다.
(이때 young 함수 실행 컨텍스트 스택은 삭제된다.)

<br>

## ```foo 함수 코드 종료``` <br>
bar 함수가 종료 되어 foo 함수도 더 이상 실행할 코드가 없으므로 foo 함수 실행컨텍스트 스택이 제거되고 종료 된다.
(전역 실행컨텍스트가 실행중인 실행컨텍스트가 된다.)

<br>

# **23.7 실행 컨텍스트와 블록 레벨 스코프**
var 키워드와 달리 let, const는 블록레벨 스코프를 갖는다. 이때의 실행컨텍스트 생성과정을 살펴보자!

<br>

```js
let x = 1;
if(ture){
    let y = 2;
    console.log(y); //2
}
console.log(x); //1
```

1. 전역코드의 x 식별자에 의해서 전역 실행컨텍스트가 생성된다.
2. if 문의 코드블록이 실행되면 블록레벨스코프를 생성을 위해 선언적 렉시컬 환경을 만들어 전역 렉시컬 환경과 교체(선언적 렉시컬 환경이 전역 실행컨텍스트 바인딩)한다.
3. if문에 의해 생성된 선언적 렉시컬 환경은 (if문이 실행되기 전 환경인)전역 렉시컬 환경을 참조한다.
4. if문 실행이 종료되면 다시 전역 렉시컬환경으로 바인딩된다.